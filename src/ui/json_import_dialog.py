"""JSON Import Dialog - Import AI-generated JSON data into Writer Platform projects."""

import json
import uuid
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from PyQt6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QTabWidget, QWidget,
    QTextEdit, QPushButton, QLabel, QScrollArea, QFrame,
    QComboBox, QGroupBox, QCheckBox, QMessageBox, QFileDialog,
    QTreeWidget, QTreeWidgetItem, QSplitter
)
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QFont


class JSONImportDialog(QDialog):
    """Dialog for importing AI-generated JSON data into the current project."""

    # Signal emitted when data is imported
    data_imported = pyqtSignal(dict)  # Emits the parsed data sections

    def __init__(self, parent=None, current_project=None):
        super().__init__(parent)
        self.setWindowTitle("Import AI-Generated Data")
        self.setMinimumSize(900, 700)
        self.resize(1000, 800)
        self.current_project = current_project
        self._parsed_data = {}
        self._init_ui()

    def _init_ui(self):
        """Initialize the UI."""
        layout = QVBoxLayout(self)
        layout.setSpacing(12)

        # Header
        header = QLabel("Import AI-Generated JSON Data")
        header.setStyleSheet("font-size: 20px; font-weight: bold; color: #6366f1; padding: 8px;")
        layout.addWidget(header)

        intro = QLabel(
            "Paste JSON data generated by AI assistants (Claude, ChatGPT, Gemini) to import into your project. "
            "The importer will detect what type of data it is and let you preview before importing."
        )
        intro.setWordWrap(True)
        intro.setStyleSheet("color: #666; padding: 0 8px 8px 8px;")
        layout.addWidget(intro)

        # Main content splitter
        splitter = QSplitter(Qt.Orientation.Horizontal)

        # Left side: JSON input
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)

        input_label = QLabel("Paste JSON data:")
        input_label.setStyleSheet("font-weight: bold;")
        left_layout.addWidget(input_label)

        self.json_input = QTextEdit()
        self.json_input.setPlaceholderText(
            "Paste your AI-generated JSON here...\n\n"
            "Supported formats:\n"
            "- Characters JSON\n"
            "- Story Planning JSON\n"
            "- Worldbuilding JSON\n"
            "- Chapter Planning JSON\n"
            "- Complete Project JSON\n\n"
            "The importer will automatically detect the format."
        )
        self.json_input.setStyleSheet("""
            QTextEdit {
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 12px;
                background-color: #f8f9fa;
                border: 1px solid #e5e7eb;
                border-radius: 6px;
                padding: 8px;
            }
        """)
        self.json_input.textChanged.connect(self._on_json_changed)
        left_layout.addWidget(self.json_input)

        # Load from file button
        load_btn = QPushButton("Load from File...")
        load_btn.clicked.connect(self._load_from_file)
        load_btn.setMaximumWidth(150)
        left_layout.addWidget(load_btn)

        splitter.addWidget(left_widget)

        # Right side: Preview
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(0, 0, 0, 0)

        preview_label = QLabel("Preview:")
        preview_label.setStyleSheet("font-weight: bold;")
        right_layout.addWidget(preview_label)

        # Status label
        self.status_label = QLabel("Waiting for JSON input...")
        self.status_label.setStyleSheet("color: #666; padding: 4px;")
        right_layout.addWidget(self.status_label)

        # Preview tree
        self.preview_tree = QTreeWidget()
        self.preview_tree.setHeaderLabels(["Element", "Type", "Details"])
        self.preview_tree.setStyleSheet("""
            QTreeWidget {
                background-color: white;
                border: 1px solid #e5e7eb;
                border-radius: 6px;
            }
        """)
        right_layout.addWidget(self.preview_tree)

        # Import options
        options_group = QGroupBox("Import Options")
        options_layout = QVBoxLayout(options_group)

        self.merge_checkbox = QCheckBox("Merge with existing data (uncheck to replace)")
        self.merge_checkbox.setChecked(True)
        options_layout.addWidget(self.merge_checkbox)

        self.skip_duplicates_checkbox = QCheckBox("Skip items with duplicate names")
        self.skip_duplicates_checkbox.setChecked(True)
        options_layout.addWidget(self.skip_duplicates_checkbox)

        self.generate_ids_checkbox = QCheckBox("Generate new IDs for all items")
        self.generate_ids_checkbox.setChecked(True)
        options_layout.addWidget(self.generate_ids_checkbox)

        right_layout.addWidget(options_group)

        # Full rebuild options
        rebuild_group = QGroupBox("Full Rebuild (Replace All)")
        rebuild_group.setStyleSheet("QGroupBox { color: #ef4444; font-weight: bold; }")
        rebuild_layout = QVBoxLayout(rebuild_group)

        rebuild_note = QLabel(
            "Select sections to completely replace with imported data.\n"
            "Chapters and annotations are NEVER affected."
        )
        rebuild_note.setWordWrap(True)
        rebuild_note.setStyleSheet("color: #666; font-weight: normal; font-size: 11px;")
        rebuild_layout.addWidget(rebuild_note)

        self.rebuild_characters_checkbox = QCheckBox("Rebuild Characters (replace all)")
        self.rebuild_characters_checkbox.setChecked(False)
        self.rebuild_characters_checkbox.toggled.connect(self._on_rebuild_toggled)
        rebuild_layout.addWidget(self.rebuild_characters_checkbox)

        self.rebuild_plot_checkbox = QCheckBox("Rebuild Plot/Story Planning (replace all)")
        self.rebuild_plot_checkbox.setChecked(False)
        self.rebuild_plot_checkbox.toggled.connect(self._on_rebuild_toggled)
        rebuild_layout.addWidget(self.rebuild_plot_checkbox)

        self.rebuild_worldbuilding_checkbox = QCheckBox("Rebuild Worldbuilding (replace all)")
        self.rebuild_worldbuilding_checkbox.setChecked(False)
        self.rebuild_worldbuilding_checkbox.toggled.connect(self._on_rebuild_toggled)
        rebuild_layout.addWidget(self.rebuild_worldbuilding_checkbox)

        right_layout.addWidget(rebuild_group)

        splitter.addWidget(right_widget)
        splitter.setSizes([500, 500])

        layout.addWidget(splitter)

        # Bottom buttons
        button_layout = QHBoxLayout()

        self.validate_btn = QPushButton("Validate JSON")
        self.validate_btn.clicked.connect(self._validate_json)
        button_layout.addWidget(self.validate_btn)

        button_layout.addStretch()

        self.import_btn = QPushButton("Import Data")
        self.import_btn.setEnabled(False)
        self.import_btn.clicked.connect(self._import_data)
        self.import_btn.setStyleSheet("""
            QPushButton {
                background-color: #10b981;
                color: white;
                font-weight: bold;
                padding: 10px 20px;
            }
            QPushButton:hover {
                background-color: #059669;
            }
            QPushButton:disabled {
                background-color: #9ca3af;
            }
        """)
        button_layout.addWidget(self.import_btn)

        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(cancel_btn)

        layout.addLayout(button_layout)

    def _on_rebuild_toggled(self, checked: bool):
        """Handle rebuild checkbox toggle - disable merge options when rebuilding."""
        any_rebuild = (
            self.rebuild_characters_checkbox.isChecked() or
            self.rebuild_plot_checkbox.isChecked() or
            self.rebuild_worldbuilding_checkbox.isChecked()
        )

        # When any rebuild is checked, disable merge and skip duplicates for those sections
        # (they don't make sense when doing a full replace)
        if any_rebuild:
            self.merge_checkbox.setEnabled(False)
            self.skip_duplicates_checkbox.setEnabled(False)
        else:
            self.merge_checkbox.setEnabled(True)
            self.skip_duplicates_checkbox.setEnabled(True)

    def _on_json_changed(self):
        """Handle JSON text changes."""
        text = self.json_input.toPlainText().strip()
        if not text:
            self.status_label.setText("Waiting for JSON input...")
            self.status_label.setStyleSheet("color: #666;")
            self.import_btn.setEnabled(False)
            self.preview_tree.clear()
            self._parsed_data = {}
            return

        # Try to parse
        try:
            self._parsed_data = json.loads(text)
            self._update_preview()
        except json.JSONDecodeError as e:
            self.status_label.setText(f"Invalid JSON: {str(e)}")
            self.status_label.setStyleSheet("color: #ef4444;")
            self.import_btn.setEnabled(False)
            self.preview_tree.clear()
            self._parsed_data = {}

    def _load_from_file(self):
        """Load JSON from a file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Load JSON File",
            "",
            "JSON Files (*.json);;All Files (*)"
        )
        if file_path:
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                self.json_input.setPlainText(content)
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Failed to load file:\n{str(e)}")

    def _validate_json(self):
        """Validate the JSON and show detailed feedback."""
        text = self.json_input.toPlainText().strip()
        if not text:
            QMessageBox.warning(self, "Validation", "No JSON data to validate.")
            return

        try:
            data = json.loads(text)
            issues = self._check_data_issues(data)

            if issues:
                msg = "JSON is valid but has some issues:\n\n"
                msg += "\n".join(f"- {issue}" for issue in issues)
                msg += "\n\nYou can still import, but some data may be skipped or modified."
                QMessageBox.information(self, "Validation", msg)
            else:
                QMessageBox.information(self, "Validation", "JSON is valid and ready to import!")
        except json.JSONDecodeError as e:
            QMessageBox.critical(self, "Validation Error", f"Invalid JSON:\n{str(e)}")

    def _check_data_issues(self, data: dict) -> List[str]:
        """Check for potential issues in the data."""
        issues = []

        # Check characters
        if 'characters' in data:
            chars = data['characters']
            if isinstance(chars, list):
                for i, char in enumerate(chars):
                    if not isinstance(char, dict):
                        issues.append(f"Character at index {i} is not an object")
                    elif 'name' not in char:
                        issues.append(f"Character at index {i} is missing 'name' field")

        # Check story_planning
        if 'story_planning' in data:
            sp = data['story_planning']
            if isinstance(sp, dict):
                if 'freytag_pyramid' in sp:
                    fp = sp['freytag_pyramid']
                    if 'events' in fp and isinstance(fp['events'], list):
                        for i, event in enumerate(fp['events']):
                            if not isinstance(event, dict):
                                issues.append(f"Event at index {i} is not an object")
                            elif 'title' not in event:
                                issues.append(f"Event at index {i} is missing 'title' field")

        # Check worldbuilding
        if 'worldbuilding' in data:
            wb = data['worldbuilding']
            if isinstance(wb, dict):
                if 'factions' in wb and isinstance(wb['factions'], list):
                    for i, faction in enumerate(wb['factions']):
                        if not isinstance(faction, dict):
                            issues.append(f"Faction at index {i} is not an object")
                        elif 'name' not in faction:
                            issues.append(f"Faction at index {i} is missing 'name' field")

        return issues

    def _update_preview(self):
        """Update the preview tree with parsed data."""
        self.preview_tree.clear()
        data = self._parsed_data

        if not data:
            return

        detected_sections = []

        # Check for characters
        if 'characters' in data and isinstance(data['characters'], list):
            chars = data['characters']
            detected_sections.append('Characters')
            chars_item = QTreeWidgetItem(["Characters", f"{len(chars)} items", ""])
            for char in chars:
                if isinstance(char, dict):
                    name = char.get('name', 'Unknown')
                    char_type = char.get('character_type', 'unknown')
                    child = QTreeWidgetItem([name, char_type, ""])
                    chars_item.addChild(child)
            self.preview_tree.addTopLevelItem(chars_item)
            chars_item.setExpanded(True)

        # Check for story_planning
        if 'story_planning' in data and isinstance(data['story_planning'], dict):
            sp = data['story_planning']
            detected_sections.append('Story Planning')
            sp_item = QTreeWidgetItem(["Story Planning", "", ""])

            # Main plot
            if sp.get('main_plot'):
                main_plot = sp['main_plot'][:50] + "..." if len(sp.get('main_plot', '')) > 50 else sp.get('main_plot', '')
                child = QTreeWidgetItem(["Main Plot", "text", main_plot])
                sp_item.addChild(child)

            # Themes
            if sp.get('themes') and isinstance(sp['themes'], list):
                themes_child = QTreeWidgetItem(["Themes", f"{len(sp['themes'])} items", ", ".join(sp['themes'][:3])])
                sp_item.addChild(themes_child)

            # Freytag pyramid
            if 'freytag_pyramid' in sp and isinstance(sp['freytag_pyramid'], dict):
                fp = sp['freytag_pyramid']
                fp_item = QTreeWidgetItem(["Freytag Pyramid", "", ""])

                for stage in ['exposition', 'rising_action', 'climax', 'falling_action', 'resolution']:
                    if fp.get(stage):
                        text = fp[stage][:40] + "..." if len(fp.get(stage, '')) > 40 else fp.get(stage, '')
                        stage_child = QTreeWidgetItem([stage.replace('_', ' ').title(), "text", text])
                        fp_item.addChild(stage_child)

                if 'events' in fp and isinstance(fp['events'], list):
                    events_child = QTreeWidgetItem(["Events", f"{len(fp['events'])} items", ""])
                    for event in fp['events'][:5]:  # Show first 5
                        if isinstance(event, dict):
                            title = event.get('title', 'Untitled')
                            stage = event.get('stage', 'unknown')
                            event_item = QTreeWidgetItem([title, stage, ""])
                            events_child.addChild(event_item)
                    if len(fp['events']) > 5:
                        more_item = QTreeWidgetItem([f"... and {len(fp['events']) - 5} more", "", ""])
                        events_child.addChild(more_item)
                    fp_item.addChild(events_child)

                sp_item.addChild(fp_item)
                fp_item.setExpanded(True)

            # Subplots
            if sp.get('subplots') and isinstance(sp['subplots'], list):
                subplots_child = QTreeWidgetItem(["Subplots", f"{len(sp['subplots'])} items", ""])
                for subplot in sp['subplots']:
                    if isinstance(subplot, dict):
                        title = subplot.get('title', 'Untitled')
                        subplot_item = QTreeWidgetItem([title, "subplot", ""])
                        subplots_child.addChild(subplot_item)
                sp_item.addChild(subplots_child)

            self.preview_tree.addTopLevelItem(sp_item)
            sp_item.setExpanded(True)

        # Check for worldbuilding
        if 'worldbuilding' in data and isinstance(data['worldbuilding'], dict):
            wb = data['worldbuilding']
            detected_sections.append('Worldbuilding')
            wb_item = QTreeWidgetItem(["Worldbuilding", "", ""])

            # Text fields
            text_fields = ['mythology', 'planets', 'climate', 'history', 'politics', 'military', 'economy', 'power_hierarchy']
            for field in text_fields:
                if wb.get(field):
                    text = wb[field][:40] + "..." if len(wb.get(field, '')) > 40 else wb.get(field, '')
                    child = QTreeWidgetItem([field.replace('_', ' ').title(), "text", text])
                    wb_item.addChild(child)

            # Factions
            if wb.get('factions') and isinstance(wb['factions'], list):
                factions_child = QTreeWidgetItem(["Factions", f"{len(wb['factions'])} items", ""])
                for faction in wb['factions']:
                    if isinstance(faction, dict):
                        name = faction.get('name', 'Unknown')
                        ftype = faction.get('faction_type', 'unknown')
                        faction_item = QTreeWidgetItem([name, ftype, ""])
                        factions_child.addChild(faction_item)
                wb_item.addChild(factions_child)

            # Myths
            if wb.get('myths') and isinstance(wb['myths'], list):
                myths_child = QTreeWidgetItem(["Myths", f"{len(wb['myths'])} items", ""])
                for myth in wb['myths']:
                    if isinstance(myth, dict):
                        name = myth.get('name', 'Unknown')
                        mtype = myth.get('myth_type', 'unknown')
                        myth_item = QTreeWidgetItem([name, mtype, ""])
                        myths_child.addChild(myth_item)
                wb_item.addChild(myths_child)

            # Places
            if wb.get('places') and isinstance(wb['places'], list):
                places_child = QTreeWidgetItem(["Places", f"{len(wb['places'])} items", ""])
                for place in wb['places']:
                    if isinstance(place, dict):
                        name = place.get('name', 'Unknown')
                        ptype = place.get('place_type', 'unknown')
                        place_item = QTreeWidgetItem([name, ptype, ""])
                        places_child.addChild(place_item)
                wb_item.addChild(places_child)

            # Custom sections
            if wb.get('custom_sections') and isinstance(wb['custom_sections'], dict):
                for section_name, section_content in wb['custom_sections'].items():
                    text = section_content[:40] + "..." if len(section_content) > 40 else section_content
                    child = QTreeWidgetItem([section_name, "custom", text])
                    wb_item.addChild(child)

            self.preview_tree.addTopLevelItem(wb_item)
            wb_item.setExpanded(True)

        # Check for chapter planning
        if 'chapter_planning' in data and isinstance(data['chapter_planning'], (list, dict)):
            cp = data['chapter_planning']
            detected_sections.append('Chapter Planning')

            # Handle both list of chapters and single chapter planning
            if isinstance(cp, dict):
                cp = [cp]  # Wrap single chapter in a list

            cp_item = QTreeWidgetItem(["Chapter Planning", f"{len(cp)} chapters", ""])

            for chapter_plan in cp:
                if isinstance(chapter_plan, dict):
                    chapter_title = chapter_plan.get('chapter_title', chapter_plan.get('title', 'Unnamed'))
                    chapter_num = chapter_plan.get('chapter_number', '?')
                    child = QTreeWidgetItem([f"Chapter {chapter_num}: {chapter_title}", "", ""])

                    # Show planning details
                    if chapter_plan.get('outline'):
                        outline_text = chapter_plan['outline'][:40] + "..." if len(chapter_plan.get('outline', '')) > 40 else chapter_plan.get('outline', '')
                        outline_child = QTreeWidgetItem(["Outline", "text", outline_text])
                        child.addChild(outline_child)

                    if chapter_plan.get('description'):
                        desc_text = chapter_plan['description'][:40] + "..." if len(chapter_plan.get('description', '')) > 40 else chapter_plan.get('description', '')
                        desc_child = QTreeWidgetItem(["Description", "text", desc_text])
                        child.addChild(desc_child)

                    if chapter_plan.get('todos') and isinstance(chapter_plan['todos'], list):
                        todos_count = len(chapter_plan['todos'])
                        completed = sum(1 for t in chapter_plan['todos'] if isinstance(t, dict) and t.get('completed'))
                        todos_child = QTreeWidgetItem(["Todos", f"{completed}/{todos_count} done", ""])
                        child.addChild(todos_child)

                    if chapter_plan.get('notes'):
                        notes_child = QTreeWidgetItem(["Notes", "text", "..."])
                        child.addChild(notes_child)

                    cp_item.addChild(child)

            self.preview_tree.addTopLevelItem(cp_item)
            cp_item.setExpanded(True)

        # Check for complete project
        if 'name' in data and ('worldbuilding' in data or 'characters' in data or 'story_planning' in data):
            if 'name' not in detected_sections:
                detected_sections.insert(0, 'Project')

        # Update status
        if detected_sections:
            self.status_label.setText(f"Detected: {', '.join(detected_sections)}")
            self.status_label.setStyleSheet("color: #10b981; font-weight: bold;")
            self.import_btn.setEnabled(True)
        else:
            self.status_label.setText("No recognized data sections found in JSON")
            self.status_label.setStyleSheet("color: #f59e0b;")
            self.import_btn.setEnabled(False)

        self.preview_tree.expandAll()

    def _import_data(self):
        """Import the parsed data into the project."""
        if not self._parsed_data:
            QMessageBox.warning(self, "Import", "No data to import.")
            return

        if not self.current_project:
            QMessageBox.warning(self, "Import", "No project is currently open.")
            return

        # Check if any rebuild options are selected
        rebuild_characters = self.rebuild_characters_checkbox.isChecked()
        rebuild_plot = self.rebuild_plot_checkbox.isChecked()
        rebuild_worldbuilding = self.rebuild_worldbuilding_checkbox.isChecked()
        any_rebuild = rebuild_characters or rebuild_plot or rebuild_worldbuilding

        # If rebuild is selected, confirm with user
        if any_rebuild:
            rebuild_sections = []
            if rebuild_characters and 'characters' in self._parsed_data:
                rebuild_sections.append("Characters")
            if rebuild_plot and 'story_planning' in self._parsed_data:
                rebuild_sections.append("Plot/Story Planning")
            if rebuild_worldbuilding and 'worldbuilding' in self._parsed_data:
                rebuild_sections.append("Worldbuilding")

            if rebuild_sections:
                msg = (
                    "You are about to COMPLETELY REPLACE the following sections:\n\n"
                    f"  {', '.join(rebuild_sections)}\n\n"
                    "All existing data in these sections will be DELETED and replaced with the imported data.\n\n"
                    "Your chapters and annotations will NOT be affected.\n\n"
                    "Are you sure you want to continue?"
                )
                reply = QMessageBox.warning(
                    self,
                    "Confirm Full Rebuild",
                    msg,
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.No
                )
                if reply != QMessageBox.StandardButton.Yes:
                    return

        try:
            merge = self.merge_checkbox.isChecked()
            skip_duplicates = self.skip_duplicates_checkbox.isChecked()
            generate_ids = self.generate_ids_checkbox.isChecked()

            import_stats = {
                'characters': 0,
                'characters_replaced': False,
                'events': 0,
                'subplots': 0,
                'plot_replaced': False,
                'factions': 0,
                'myths': 0,
                'places': 0,
                'text_fields': 0,
                'worldbuilding_replaced': False
            }

            # Import characters
            if 'characters' in self._parsed_data:
                if rebuild_characters:
                    # Full rebuild - clear existing characters first
                    count = self._rebuild_characters(self._parsed_data['characters'], generate_ids)
                    import_stats['characters'] = count
                    import_stats['characters_replaced'] = True
                else:
                    count = self._import_characters(
                        self._parsed_data['characters'],
                        merge, skip_duplicates, generate_ids
                    )
                    import_stats['characters'] = count

            # Import story planning
            if 'story_planning' in self._parsed_data:
                if rebuild_plot:
                    # Full rebuild - clear existing plot data first
                    stats = self._rebuild_story_planning(self._parsed_data['story_planning'], generate_ids)
                    import_stats.update(stats)
                    import_stats['plot_replaced'] = True
                else:
                    stats = self._import_story_planning(
                        self._parsed_data['story_planning'],
                        merge, skip_duplicates, generate_ids
                    )
                    import_stats.update(stats)

            # Import worldbuilding
            if 'worldbuilding' in self._parsed_data:
                if rebuild_worldbuilding:
                    # Full rebuild - clear existing worldbuilding first
                    stats = self._rebuild_worldbuilding(self._parsed_data['worldbuilding'], generate_ids)
                    import_stats.update(stats)
                    import_stats['worldbuilding_replaced'] = True
                else:
                    stats = self._import_worldbuilding(
                        self._parsed_data['worldbuilding'],
                        merge, skip_duplicates, generate_ids
                    )
                    import_stats.update(stats)

            # Import chapter planning
            if 'chapter_planning' in self._parsed_data:
                count = self._import_chapter_planning(
                    self._parsed_data['chapter_planning'],
                    merge, generate_ids
                )
                import_stats['chapter_plans'] = count

            # Show summary
            summary_lines = []

            if import_stats['characters_replaced']:
                summary_lines.append(f"- Characters REPLACED: {import_stats['characters']} imported")
            elif import_stats['characters']:
                summary_lines.append(f"- {import_stats['characters']} characters added")

            if import_stats['plot_replaced']:
                summary_lines.append(f"- Plot REPLACED: {import_stats['events']} events, {import_stats['subplots']} subplots")
            else:
                if import_stats['events']:
                    summary_lines.append(f"- {import_stats['events']} plot events added")
                if import_stats['subplots']:
                    summary_lines.append(f"- {import_stats['subplots']} subplots added")

            if import_stats['worldbuilding_replaced']:
                summary_lines.append(f"- Worldbuilding REPLACED: {import_stats['factions']} factions, {import_stats['myths']} myths, {import_stats['places']} places")
            else:
                if import_stats['factions']:
                    summary_lines.append(f"- {import_stats['factions']} factions added")
                if import_stats['myths']:
                    summary_lines.append(f"- {import_stats['myths']} myths added")
                if import_stats['places']:
                    summary_lines.append(f"- {import_stats['places']} places added")

            if import_stats['text_fields']:
                summary_lines.append(f"- {import_stats['text_fields']} text fields updated")

            if import_stats.get('chapter_plans'):
                summary_lines.append(f"- {import_stats['chapter_plans']} chapter plans updated")

            if summary_lines:
                msg = "Successfully imported:\n\n" + "\n".join(summary_lines)
                QMessageBox.information(self, "Import Complete", msg)
                self.data_imported.emit(self._parsed_data)
                self.accept()
            else:
                QMessageBox.warning(self, "Import", "No data was imported. Check that your JSON format is correct.")

        except Exception as e:
            QMessageBox.critical(self, "Import Error", f"Failed to import data:\n{str(e)}")

    def _generate_id(self, prefix: str) -> str:
        """Generate a unique ID."""
        return f"{prefix}_{uuid.uuid4().hex[:8]}"

    def _import_characters(self, chars_data: list, merge: bool, skip_duplicates: bool, generate_ids: bool) -> int:
        """Import characters into the project."""
        if not isinstance(chars_data, list):
            return 0

        from src.models.project import Character

        existing_names = {c.name.lower() for c in self.current_project.characters} if skip_duplicates else set()
        imported = 0

        for char_data in chars_data:
            if not isinstance(char_data, dict):
                continue

            name = char_data.get('name', '')
            if not name:
                continue

            if skip_duplicates and name.lower() in existing_names:
                continue

            # Generate or use existing ID
            char_id = self._generate_id('char') if generate_ids else char_data.get('id', self._generate_id('char'))

            # Create character
            char = Character(
                id=char_id,
                name=name,
                character_type=char_data.get('character_type', 'minor'),
                personality=char_data.get('personality', ''),
                backstory=char_data.get('backstory', ''),
                social_network=char_data.get('social_network', {}),
                notes=char_data.get('notes', '')
            )

            self.current_project.characters.append(char)
            existing_names.add(name.lower())
            imported += 1

        return imported

    def _import_story_planning(self, sp_data: dict, merge: bool, skip_duplicates: bool, generate_ids: bool) -> dict:
        """Import story planning data."""
        if not isinstance(sp_data, dict):
            return {}

        from src.models.project import PlotEvent, Subplot

        stats = {'events': 0, 'subplots': 0, 'text_fields': 0}
        sp = self.current_project.story_planning

        # Import main plot
        if sp_data.get('main_plot'):
            if merge and sp.main_plot:
                sp.main_plot += "\n\n--- Imported ---\n\n" + sp_data['main_plot']
            else:
                sp.main_plot = sp_data['main_plot']
            stats['text_fields'] += 1

        # Import themes
        if sp_data.get('themes') and isinstance(sp_data['themes'], list):
            if merge:
                existing_themes = set(sp.themes)
                for theme in sp_data['themes']:
                    if theme not in existing_themes:
                        sp.themes.append(theme)
            else:
                sp.themes = sp_data['themes']

        # Import freytag pyramid
        if 'freytag_pyramid' in sp_data and isinstance(sp_data['freytag_pyramid'], dict):
            fp_data = sp_data['freytag_pyramid']
            fp = sp.freytag_pyramid

            # Text fields
            for stage in ['exposition', 'rising_action', 'climax', 'falling_action', 'resolution']:
                if fp_data.get(stage):
                    current = getattr(fp, stage, '')
                    if merge and current:
                        setattr(fp, stage, current + "\n\n--- Imported ---\n\n" + fp_data[stage])
                    else:
                        setattr(fp, stage, fp_data[stage])
                    stats['text_fields'] += 1

            # Events
            if 'events' in fp_data and isinstance(fp_data['events'], list):
                existing_titles = {e.title.lower() for e in fp.events} if skip_duplicates else set()

                for event_data in fp_data['events']:
                    if not isinstance(event_data, dict):
                        continue

                    title = event_data.get('title', '')
                    if not title:
                        continue

                    if skip_duplicates and title.lower() in existing_titles:
                        continue

                    event_id = self._generate_id('event') if generate_ids else event_data.get('id', self._generate_id('event'))

                    event = PlotEvent(
                        id=event_id,
                        title=title,
                        description=event_data.get('description', ''),
                        outcome=event_data.get('outcome', ''),
                        stage=event_data.get('stage', 'rising_action'),
                        intensity=event_data.get('intensity', 50),
                        sort_order=event_data.get('sort_order', len(fp.events)),
                        related_characters=event_data.get('related_characters', []),
                        notes=event_data.get('notes', '')
                    )

                    fp.events.append(event)
                    existing_titles.add(title.lower())
                    stats['events'] += 1

        # Import subplots
        if 'subplots' in sp_data and isinstance(sp_data['subplots'], list):
            existing_titles = {s.title.lower() for s in sp.subplots} if skip_duplicates else set()

            for subplot_data in sp_data['subplots']:
                if not isinstance(subplot_data, dict):
                    continue

                title = subplot_data.get('title', '')
                if not title:
                    continue

                if skip_duplicates and title.lower() in existing_titles:
                    continue

                subplot_id = self._generate_id('subplot') if generate_ids else subplot_data.get('id', self._generate_id('subplot'))

                subplot = Subplot(
                    id=subplot_id,
                    title=title,
                    description=subplot_data.get('description', ''),
                    connection_to_main=subplot_data.get('connection_to_main', ''),
                    related_characters=subplot_data.get('related_characters', []),
                    status=subplot_data.get('status', 'active')
                )

                sp.subplots.append(subplot)
                existing_titles.add(title.lower())
                stats['subplots'] += 1

        return stats

    def _import_worldbuilding(self, wb_data: dict, merge: bool, skip_duplicates: bool, generate_ids: bool) -> dict:
        """Import worldbuilding data."""
        if not isinstance(wb_data, dict):
            return {}

        from src.models.worldbuilding_objects import Faction, Myth, Place

        stats = {'factions': 0, 'myths': 0, 'places': 0, 'text_fields': 0}
        wb = self.current_project.worldbuilding

        # Text fields
        text_fields = ['mythology', 'planets', 'climate', 'history', 'politics', 'military', 'economy', 'power_hierarchy']
        for field in text_fields:
            if wb_data.get(field):
                current = getattr(wb, field, '')
                if merge and current:
                    setattr(wb, field, current + "\n\n--- Imported ---\n\n" + wb_data[field])
                else:
                    setattr(wb, field, wb_data[field])
                stats['text_fields'] += 1

        # Custom sections
        if wb_data.get('custom_sections') and isinstance(wb_data['custom_sections'], dict):
            for section_name, section_content in wb_data['custom_sections'].items():
                if section_name in wb.custom_sections and merge:
                    wb.custom_sections[section_name] += "\n\n--- Imported ---\n\n" + section_content
                else:
                    wb.custom_sections[section_name] = section_content
                stats['text_fields'] += 1

        # Factions
        if 'factions' in wb_data and isinstance(wb_data['factions'], list):
            existing_names = {f.name.lower() for f in wb.factions} if skip_duplicates else set()

            for faction_data in wb_data['factions']:
                if not isinstance(faction_data, dict):
                    continue

                name = faction_data.get('name', '')
                if not name:
                    continue

                if skip_duplicates and name.lower() in existing_names:
                    continue

                faction_id = self._generate_id('faction') if generate_ids else faction_data.get('id', self._generate_id('faction'))

                faction = Faction(
                    id=faction_id,
                    name=name,
                    faction_type=faction_data.get('faction_type', 'other'),
                    description=faction_data.get('description', ''),
                    leader=faction_data.get('leader'),
                    territory=faction_data.get('territory', []),
                    allies=faction_data.get('allies', []),
                    enemies=faction_data.get('enemies', []),
                    military_strength=faction_data.get('military_strength', 50),
                    economic_power=faction_data.get('economic_power', 50),
                    notes=faction_data.get('notes', '')
                )

                wb.factions.append(faction)
                existing_names.add(name.lower())
                stats['factions'] += 1

        # Myths
        if 'myths' in wb_data and isinstance(wb_data['myths'], list):
            existing_names = {m.name.lower() for m in wb.myths} if skip_duplicates else set()

            for myth_data in wb_data['myths']:
                if not isinstance(myth_data, dict):
                    continue

                name = myth_data.get('name', '')
                if not name:
                    continue

                if skip_duplicates and name.lower() in existing_names:
                    continue

                myth_id = self._generate_id('myth') if generate_ids else myth_data.get('id', self._generate_id('myth'))

                myth = Myth(
                    id=myth_id,
                    name=name,
                    myth_type=myth_data.get('myth_type', 'legend'),
                    description=myth_data.get('description', ''),
                    full_text=myth_data.get('full_text', ''),
                    moral_lesson=myth_data.get('moral_lesson', ''),
                    associated_factions=myth_data.get('associated_factions', [])
                )

                wb.myths.append(myth)
                existing_names.add(name.lower())
                stats['myths'] += 1

        # Places
        if 'places' in wb_data and isinstance(wb_data['places'], list):
            existing_names = {p.name.lower() for p in wb.places} if skip_duplicates else set()

            for place_data in wb_data['places']:
                if not isinstance(place_data, dict):
                    continue

                name = place_data.get('name', '')
                if not name:
                    continue

                if skip_duplicates and name.lower() in existing_names:
                    continue

                place_id = self._generate_id('place') if generate_ids else place_data.get('id', self._generate_id('place'))

                place = Place(
                    id=place_id,
                    name=name,
                    place_type=place_data.get('place_type', 'city'),
                    description=place_data.get('description', ''),
                    planet=place_data.get('planet'),
                    continent=place_data.get('continent'),
                    region=place_data.get('region'),
                    controlling_faction=place_data.get('controlling_faction'),
                    contested_by=place_data.get('contested_by', []),
                    key_features=place_data.get('key_features', []),
                    strategic_value=place_data.get('strategic_value', 50),
                    economic_value=place_data.get('economic_value', 50),
                    cultural_significance=place_data.get('cultural_significance', ''),
                    notable_inhabitants=place_data.get('notable_inhabitants', []),
                    atmosphere=place_data.get('atmosphere', ''),
                    story_relevance=place_data.get('story_relevance', ''),
                    notes=place_data.get('notes', '')
                )

                wb.places.append(place)
                existing_names.add(name.lower())
                stats['places'] += 1

        return stats

    def _rebuild_characters(self, chars_data: list, generate_ids: bool) -> int:
        """Completely replace all characters with imported data.

        This clears all existing characters and imports the new ones.
        Chapters and annotations are NOT affected.
        """
        if not isinstance(chars_data, list):
            return 0

        from src.models.project import Character

        # Clear all existing characters
        self.current_project.characters.clear()

        imported = 0
        for char_data in chars_data:
            if not isinstance(char_data, dict):
                continue

            name = char_data.get('name', '')
            if not name:
                continue

            # Generate or use existing ID
            char_id = self._generate_id('char') if generate_ids else char_data.get('id', self._generate_id('char'))

            # Create character
            char = Character(
                id=char_id,
                name=name,
                character_type=char_data.get('character_type', 'minor'),
                personality=char_data.get('personality', ''),
                backstory=char_data.get('backstory', ''),
                social_network=char_data.get('social_network', {}),
                notes=char_data.get('notes', '')
            )

            self.current_project.characters.append(char)
            imported += 1

        return imported

    def _rebuild_story_planning(self, sp_data: dict, generate_ids: bool) -> dict:
        """Completely replace story planning data with imported data.

        This clears all existing plot events, subplots, themes, and text fields.
        Chapters and annotations are NOT affected.
        """
        if not isinstance(sp_data, dict):
            return {}

        from src.models.project import PlotEvent, Subplot, FreytagPyramid

        stats = {'events': 0, 'subplots': 0, 'text_fields': 0}
        sp = self.current_project.story_planning

        # Clear existing data
        sp.main_plot = ""
        sp.themes.clear()
        sp.subplots.clear()
        sp.freytag_pyramid = FreytagPyramid()

        # Import main plot
        if sp_data.get('main_plot'):
            sp.main_plot = sp_data['main_plot']
            stats['text_fields'] += 1

        # Import themes
        if sp_data.get('themes') and isinstance(sp_data['themes'], list):
            sp.themes = list(sp_data['themes'])

        # Import freytag pyramid
        if 'freytag_pyramid' in sp_data and isinstance(sp_data['freytag_pyramid'], dict):
            fp_data = sp_data['freytag_pyramid']
            fp = sp.freytag_pyramid

            # Text fields
            for stage in ['exposition', 'rising_action', 'climax', 'falling_action', 'resolution']:
                if fp_data.get(stage):
                    setattr(fp, stage, fp_data[stage])
                    stats['text_fields'] += 1

            # Events
            if 'events' in fp_data and isinstance(fp_data['events'], list):
                for event_data in fp_data['events']:
                    if not isinstance(event_data, dict):
                        continue

                    title = event_data.get('title', '')
                    if not title:
                        continue

                    event_id = self._generate_id('event') if generate_ids else event_data.get('id', self._generate_id('event'))

                    event = PlotEvent(
                        id=event_id,
                        title=title,
                        description=event_data.get('description', ''),
                        outcome=event_data.get('outcome', ''),
                        stage=event_data.get('stage', 'rising_action'),
                        intensity=event_data.get('intensity', 50),
                        sort_order=event_data.get('sort_order', len(fp.events)),
                        related_characters=event_data.get('related_characters', []),
                        notes=event_data.get('notes', '')
                    )

                    fp.events.append(event)
                    stats['events'] += 1

        # Import subplots
        if 'subplots' in sp_data and isinstance(sp_data['subplots'], list):
            for subplot_data in sp_data['subplots']:
                if not isinstance(subplot_data, dict):
                    continue

                title = subplot_data.get('title', '')
                if not title:
                    continue

                subplot_id = self._generate_id('subplot') if generate_ids else subplot_data.get('id', self._generate_id('subplot'))

                subplot = Subplot(
                    id=subplot_id,
                    title=title,
                    description=subplot_data.get('description', ''),
                    connection_to_main=subplot_data.get('connection_to_main', ''),
                    related_characters=subplot_data.get('related_characters', []),
                    status=subplot_data.get('status', 'active')
                )

                sp.subplots.append(subplot)
                stats['subplots'] += 1

        return stats

    def _rebuild_worldbuilding(self, wb_data: dict, generate_ids: bool) -> dict:
        """Completely replace worldbuilding data with imported data.

        This clears all existing worldbuilding text fields, factions, myths, etc.
        Chapters and annotations are NOT affected.
        """
        if not isinstance(wb_data, dict):
            return {}

        from src.models.worldbuilding_objects import Faction, Myth, Place
        from src.models.project import WorldBuilding

        stats = {'factions': 0, 'myths': 0, 'places': 0, 'text_fields': 0}

        # Create fresh worldbuilding object but preserve any fields we don't handle
        wb = self.current_project.worldbuilding

        # Clear text fields
        text_fields = ['mythology', 'planets', 'climate', 'history', 'politics', 'military', 'economy', 'power_hierarchy']
        for field in text_fields:
            setattr(wb, field, '')

        # Clear custom sections
        wb.custom_sections.clear()

        # Clear structured objects
        wb.factions.clear()
        wb.myths.clear()
        wb.places.clear()

        # Import text fields
        for field in text_fields:
            if wb_data.get(field):
                setattr(wb, field, wb_data[field])
                stats['text_fields'] += 1

        # Import custom sections
        if wb_data.get('custom_sections') and isinstance(wb_data['custom_sections'], dict):
            for section_name, section_content in wb_data['custom_sections'].items():
                wb.custom_sections[section_name] = section_content
                stats['text_fields'] += 1

        # Import factions
        if 'factions' in wb_data and isinstance(wb_data['factions'], list):
            for faction_data in wb_data['factions']:
                if not isinstance(faction_data, dict):
                    continue

                name = faction_data.get('name', '')
                if not name:
                    continue

                faction_id = self._generate_id('faction') if generate_ids else faction_data.get('id', self._generate_id('faction'))

                faction = Faction(
                    id=faction_id,
                    name=name,
                    faction_type=faction_data.get('faction_type', 'other'),
                    description=faction_data.get('description', ''),
                    leader=faction_data.get('leader'),
                    territory=faction_data.get('territory', []),
                    allies=faction_data.get('allies', []),
                    enemies=faction_data.get('enemies', []),
                    military_strength=faction_data.get('military_strength', 50),
                    economic_power=faction_data.get('economic_power', 50),
                    notes=faction_data.get('notes', '')
                )

                wb.factions.append(faction)
                stats['factions'] += 1

        # Import myths
        if 'myths' in wb_data and isinstance(wb_data['myths'], list):
            for myth_data in wb_data['myths']:
                if not isinstance(myth_data, dict):
                    continue

                name = myth_data.get('name', '')
                if not name:
                    continue

                myth_id = self._generate_id('myth') if generate_ids else myth_data.get('id', self._generate_id('myth'))

                myth = Myth(
                    id=myth_id,
                    name=name,
                    myth_type=myth_data.get('myth_type', 'legend'),
                    description=myth_data.get('description', ''),
                    full_text=myth_data.get('full_text', ''),
                    moral_lesson=myth_data.get('moral_lesson', ''),
                    associated_factions=myth_data.get('associated_factions', [])
                )

                wb.myths.append(myth)
                stats['myths'] += 1

        # Import places
        if 'places' in wb_data and isinstance(wb_data['places'], list):
            for place_data in wb_data['places']:
                if not isinstance(place_data, dict):
                    continue

                name = place_data.get('name', '')
                if not name:
                    continue

                place_id = self._generate_id('place') if generate_ids else place_data.get('id', self._generate_id('place'))

                place = Place(
                    id=place_id,
                    name=name,
                    place_type=place_data.get('place_type', 'city'),
                    description=place_data.get('description', ''),
                    planet=place_data.get('planet'),
                    continent=place_data.get('continent'),
                    region=place_data.get('region'),
                    controlling_faction=place_data.get('controlling_faction'),
                    contested_by=place_data.get('contested_by', []),
                    key_features=place_data.get('key_features', []),
                    strategic_value=place_data.get('strategic_value', 50),
                    economic_value=place_data.get('economic_value', 50),
                    cultural_significance=place_data.get('cultural_significance', ''),
                    notable_inhabitants=place_data.get('notable_inhabitants', []),
                    atmosphere=place_data.get('atmosphere', ''),
                    story_relevance=place_data.get('story_relevance', ''),
                    notes=place_data.get('notes', '')
                )

                wb.places.append(place)
                stats['places'] += 1

        return stats

    def _import_chapter_planning(self, cp_data, merge: bool, generate_ids: bool) -> int:
        """Import chapter planning data into existing chapters.

        Matches chapters by number or title and updates their planning data.
        This does NOT create new chapters - only updates existing ones.

        Args:
            cp_data: Chapter planning data (list of dicts or single dict)
            merge: Whether to merge with existing planning (vs replace)
            generate_ids: Whether to generate new IDs for todos

        Returns:
            Number of chapters updated
        """
        from src.models.project import ChapterTodo

        # Ensure we have a list
        if isinstance(cp_data, dict):
            cp_data = [cp_data]

        if not isinstance(cp_data, list):
            return 0

        # Get existing chapters from manuscript
        if not self.current_project.manuscript or not self.current_project.manuscript.chapters:
            return 0

        chapters = self.current_project.manuscript.chapters
        updated = 0

        for plan_data in cp_data:
            if not isinstance(plan_data, dict):
                continue

            # Find matching chapter by number or title
            chapter_num = plan_data.get('chapter_number')
            chapter_title = plan_data.get('chapter_title', plan_data.get('title', ''))

            target_chapter = None

            # First try to match by chapter number
            if chapter_num is not None:
                for ch in chapters:
                    if ch.number == chapter_num:
                        target_chapter = ch
                        break

            # Fall back to matching by title
            if not target_chapter and chapter_title:
                chapter_title_lower = chapter_title.lower().strip()
                for ch in chapters:
                    if ch.title.lower().strip() == chapter_title_lower:
                        target_chapter = ch
                        break

            if not target_chapter:
                continue

            # Update planning data
            planning = target_chapter.planning

            # Outline
            if 'outline' in plan_data:
                if merge and planning.outline:
                    planning.outline += "\n\n--- Imported ---\n\n" + plan_data['outline']
                else:
                    planning.outline = plan_data['outline']
                # Also update legacy plan field
                target_chapter.plan = planning.outline

            # Description
            if 'description' in plan_data:
                if merge and planning.description:
                    planning.description += "\n\n--- Imported ---\n\n" + plan_data['description']
                else:
                    planning.description = plan_data['description']

            # Notes
            if 'notes' in plan_data:
                if merge and planning.notes:
                    planning.notes += "\n\n--- Imported ---\n\n" + plan_data['notes']
                else:
                    planning.notes = plan_data['notes']

            # Todos
            if 'todos' in plan_data and isinstance(plan_data['todos'], list):
                if not merge:
                    planning.todos.clear()

                existing_texts = {t.text.lower().strip() for t in planning.todos} if merge else set()

                for todo_data in plan_data['todos']:
                    if isinstance(todo_data, str):
                        # Simple string todo
                        if todo_data.lower().strip() not in existing_texts:
                            todo = ChapterTodo(
                                id=self._generate_id('todo') if generate_ids else str(uuid.uuid4()),
                                text=todo_data,
                                completed=False,
                                priority='normal'
                            )
                            planning.todos.append(todo)
                            existing_texts.add(todo_data.lower().strip())
                    elif isinstance(todo_data, dict):
                        text = todo_data.get('text', '')
                        if text and text.lower().strip() not in existing_texts:
                            todo_id = self._generate_id('todo') if generate_ids else todo_data.get('id', str(uuid.uuid4()))
                            todo = ChapterTodo(
                                id=todo_id,
                                text=text,
                                completed=todo_data.get('completed', False),
                                priority=todo_data.get('priority', 'normal')
                            )
                            planning.todos.append(todo)
                            existing_texts.add(text.lower().strip())

            # Scene list
            if 'scene_list' in plan_data and isinstance(plan_data['scene_list'], list):
                if merge:
                    existing = set(planning.scene_list)
                    for scene in plan_data['scene_list']:
                        if scene not in existing:
                            planning.scene_list.append(scene)
                else:
                    planning.scene_list = list(plan_data['scene_list'])

            # Characters featured
            if 'characters_featured' in plan_data and isinstance(plan_data['characters_featured'], list):
                if merge:
                    existing = set(planning.characters_featured)
                    for char in plan_data['characters_featured']:
                        if char not in existing:
                            planning.characters_featured.append(char)
                else:
                    planning.characters_featured = list(plan_data['characters_featured'])

            # Locations
            if 'locations' in plan_data and isinstance(plan_data['locations'], list):
                if merge:
                    existing = set(planning.locations)
                    for loc in plan_data['locations']:
                        if loc not in existing:
                            planning.locations.append(loc)
                else:
                    planning.locations = list(plan_data['locations'])

            # Themes
            if 'themes' in plan_data and isinstance(plan_data['themes'], list):
                if merge:
                    existing = set(planning.themes)
                    for theme in plan_data['themes']:
                        if theme not in existing:
                            planning.themes.append(theme)
                else:
                    planning.themes = list(plan_data['themes'])

            # POV character
            if 'pov_character' in plan_data:
                planning.pov_character = plan_data['pov_character']

            # Timeline position
            if 'timeline_position' in plan_data:
                planning.timeline_position = plan_data['timeline_position']

            updated += 1

        return updated
